# -*- coding: utf8 -*-
"""Autogenerated file - DO NOT EDIT
If you spot a bug, please report it on the mailing list and/or change the generator."""

from nipype.interfaces.base import CommandLine, CommandLineInputSpec, SEMLikeCommandLine, TraitedSpec, File, Directory, traits, isdefined, InputMultiPath, OutputMultiPath
import os


class dtiprocessInputSpec(CommandLineInputSpec):
    dti_image = File(desc="DTI tensor volume", exists=True, argstr="--dti_image %s")
    fa_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Fractional Anisotropy output file", argstr="--fa_output %s")
    md_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Mean Diffusivity output file", argstr="--md_output %s")
    sigma = traits.Float(desc="Scale of gradients", argstr="--sigma %f")
    fa_gradient_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Fractional Anisotropy Gradient output file", argstr="--fa_gradient_output %s")
    fa_gradmag_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Fractional Anisotropy Gradient Magnitude output file", argstr="--fa_gradmag_output %s")
    color_fa_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Color Fractional Anisotropy output file", argstr="--color_fa_output %s")
    principal_eigenvector_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Principal Eigenvectors Output", argstr="--principal_eigenvector_output %s")
    negative_eigenvector_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Negative Eigenvectors Output: create a binary image where if any of the eigen value is below zero, the voxel is set to 1, otherwise 0.", argstr="--negative_eigenvector_output %s")
    frobenius_norm_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Frobenius Norm Output", argstr="--frobenius_norm_output %s")
    lambda1_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Axial Diffusivity - Lambda 1 (largest eigenvalue) output", argstr="--lambda1_output %s")
    lambda2_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Lambda 2 (middle eigenvalue) output", argstr="--lambda2_output %s")
    lambda3_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Lambda 3 (smallest eigenvalue) output", argstr="--lambda3_output %s")
    RD_output = traits.Either(traits.Bool, File(), hash_files=False, desc="RD (Radial Diffusivity 1/2*(lambda2+lambda3)) output", argstr="--RD_output %s")
    rot_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Rotated tensor output file.  Must also specify the dof file.", argstr="--rot_output %s")
    affineitk_file = File(desc="Transformation file for affine transformation.  ITK format.", exists=True, argstr="--affineitk_file %s")
    dof_file = File(desc="Transformation file for affine transformation.  This can be ITK format (or the outdated RView).", exists=True, argstr="--dof_file %s")
    newdof_file = File(desc="Transformation file for affine transformation.  RView NEW format. (txt file output of dof2mat)", exists=True, argstr="--newdof_file %s")
    mask = File(desc="Mask tensors. Specify --outmask if you want to save the masked tensor field, otherwise the mask is applied just for the current processing ", exists=True, argstr="--mask %s")
    outmask = traits.Either(traits.Bool, File(), hash_files=False, desc="Name of the masked tensor field.", argstr="--outmask %s")
    hField = traits.Bool(desc="forward and inverse transformations are h-fields instead of displacement fields", argstr="--hField ")
    forward = File(desc="Forward transformation.  Assumed to be a deformation field in world coordinates, unless the --h-field option is specified.", exists=True, argstr="--forward %s")
    deformation_output = traits.Either(traits.Bool, File(), hash_files=False, desc="Warped tensor field based on a deformation field.  This option requires the --forward,-F transformation to be specified.", argstr="--deformation_output %s")
    interpolation = traits.Enum("nearestneighbor", "linear", "cubic", desc="Interpolation type (nearestneighbor, linear, cubic)", argstr="--interpolation %s")
    reorientation = traits.Enum("fs", "ppd", desc="Reorientation type (fs, ppd)", argstr="--reorientation %s")
    scalar_float = traits.Bool(desc="Write scalar [FA,MD] as unscaled float (with their actual values, otherwise scaled by 10 000).  Also causes FA to be unscaled [0..1].", argstr="--scalar_float ")
    DTI_double = traits.Bool(desc="Tensor components are saved as doubles (cannot be visualized in Slicer)", argstr="--DTI_double ")
    verbose = traits.Bool(desc="produce verbose output", argstr="--verbose ")


class dtiprocessOutputSpec(TraitedSpec):
    fa_output = File(desc="Fractional Anisotropy output file", exists=True)
    md_output = File(desc="Mean Diffusivity output file", exists=True)
    fa_gradient_output = File(desc="Fractional Anisotropy Gradient output file", exists=True)
    fa_gradmag_output = File(desc="Fractional Anisotropy Gradient Magnitude output file", exists=True)
    color_fa_output = File(desc="Color Fractional Anisotropy output file", exists=True)
    principal_eigenvector_output = File(desc="Principal Eigenvectors Output", exists=True)
    negative_eigenvector_output = File(desc="Negative Eigenvectors Output: create a binary image where if any of the eigen value is below zero, the voxel is set to 1, otherwise 0.", exists=True)
    frobenius_norm_output = File(desc="Frobenius Norm Output", exists=True)
    lambda1_output = File(desc="Axial Diffusivity - Lambda 1 (largest eigenvalue) output", exists=True)
    lambda2_output = File(desc="Lambda 2 (middle eigenvalue) output", exists=True)
    lambda3_output = File(desc="Lambda 3 (smallest eigenvalue) output", exists=True)
    RD_output = File(desc="RD (Radial Diffusivity 1/2*(lambda2+lambda3)) output", exists=True)
    rot_output = File(desc="Rotated tensor output file.  Must also specify the dof file.", exists=True)
    outmask = File(desc="Name of the masked tensor field.", exists=True)
    deformation_output = File(desc="Warped tensor field based on a deformation field.  This option requires the --forward,-F transformation to be specified.", exists=True)


class dtiprocess(SEMLikeCommandLine):

    """title: DTIProcess

category: Diffusion.NIRALPipeline

description:  
dtiprocess is a tool that handles tensor fields. It takes as an input a tensor field in nrrd format.
It can generate diffusion scalar properties out of the tensor field such as : FA (--fa_output), Gradient FA image (--fa_gradient_output), color FA (--color_fa_output), MD (--md_output), Frobenius norm (--frobenius_norm_output), lbd1, lbd2, lbd3 (--lambda{1,2,3}_output), binary map of voxel where if any of the eigenvalue is negative, the voxel is set to 1 (--negative_eigenvector_output) 
It also creates 4D images out of the tensor field such as: Highest eigenvector map (highest eigenvector at each voxel) (--principal_eigenvector_output)
 Masking capabilities: For any of the processing done with dtiprocess, it's possible to apply it on a masked region of the tensor field. You need to use the --mask option for any of the option to be applied on that tensor field sub-region only. If you want to save the masked tensor field use the option --outmask and specify the new masked tensor field file name.
dtiprocess also allows a range of transformations on the tensor fields. The transformed tensor field file name is specified with the option --deformation_output. There are 3 resampling interpolation methods specified with the tag --interpolation followed by the type to use (nearestneighbor, linear, cubic) Then you have several transformations possible to apply:
        - Affine transformations using as an input 
        - itk affine transformation file (based on the itkAffineTransform class)
        - Affine transformations using rview (details and download at http://www.doc.ic.ac.uk/~dr/software/). There are 2 versions of rview both creating transformation files called dof files. The old version of rview outputs text files containing the transformation parameters. It can be read in with the --dof_file option. The new version outputs binary dof files. These dof files can be transformed into human readable file with the dof2mat tool which is part of the rview package. So you need to save the output of dof2mat into a text file which can then be used with the -- newdof_file option. Usage example: dof2mat mynewdoffile.dof >> mynewdoffile.txt 	 dtiprocess --dti_image mytensorfield.nhdr --newdof_file mynewdoffile.txt --rot_output myaffinetensorfield.nhdr 
Non linear transformations as an input: The default transformation file type is d-field (displacement field) in nrrd format. The option to use is --forward with the name of the file. If the transformation file is a h-field you have to add the option --hField. 

version: 1.0.1

documentation-url: http://www.google.com/

license: 
  Copyright (c)  Casey Goodlett. All rights reserved.
  See http://www.ia.unc.edu/dev/Copyright.htm for details.
     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.


contributor: Casey Goodlett

"""

    input_spec = dtiprocessInputSpec
    output_spec = dtiprocessOutputSpec
    _cmd = " dtiprocess "
    _outputs_filenames = {'fa_gradmag_output': 'fa_gradmag_output.nii', 'fa_gradient_output': 'fa_gradient_output.nii', 'lambda1_output': 'lambda1_output.nii', 'lambda2_output': 'lambda2_output.nii', 'color_fa_output': 'color_fa_output.nii', 'fa_output': 'fa_output.nii', 'frobenius_norm_output': 'frobenius_norm_output.nii',
                          'principal_eigenvector_output': 'principal_eigenvector_output.nii', 'outmask': 'outmask.nii', 'lambda3_output': 'lambda3_output.nii', 'negative_eigenvector_output': 'negative_eigenvector_output.nii', 'md_output': 'md_output.nii', 'RD_output': 'RD_output.nii', 'deformation_output': 'deformation_output.nii', 'rot_output': 'rot_output.nii'}
